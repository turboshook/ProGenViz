extends MapGenerator

func _init() -> void:
	_default_parameters = {
		"map_size": Vector2i(32, 32),	# Total map size.
		"cell_count": 16				# The number of cells that will be generated within the map.
	}
	_info_text = "\
		This algorithm creates partitions in a plane of a given size. A number of coordinates within \
		the plane are randomly selected as the partition (cell) origin. A tile's cell membership is \
		determined simply by finding what cell origin is nearest.
		
		These structures may be useful for world generation, but they can also be used as a post-processing \
		step to create regional data for maps generated by other means.\
	"

@warning_ignore("unused_parameter")
func generate(parameters: Dictionary) -> void:
	_gen_data = {
		"map_size": parameters.map_size, 	# Used to calculate the center position offset.
		"cells": [], 						# Array of dictionaries describing a cell by its origin and what tiles belong to them.
		"tiles": [] 						# Array of dictionaries describing tiles by their position and what cell they belong to.
	}
	# This implementation records cells and tiles simultaneously in order to more easily support 
	# generalized use cases, but the visualization does not use _gen_data.tiles.
	
	# Initialize the generation data dictionary with empty cells with random origins
	for _i: int in range(parameters.cell_count):
		var cell_origin: Vector2i = GeneratorUtils.get_rect_random_point(Rect2i(Vector2i.ZERO, parameters.map_size))
		
		# cell origin buffer radius constraint
		# cannot resolve for small maps with relatively high cell counts
		#var cell_origin: Vector2i = Vector2i.ZERO
		#var cell_origin_isolated: bool = false
		#while !cell_origin_isolated:
			#cell_origin = GeneratorUtils.get_rect_random_point(Rect2i(Vector2i.ZERO, parameters.map_size))
			#cell_origin_isolated = true
			#for i: int in range(_gen_data.cells.size()):
				#var other_cell_origin: Vector2i = _gen_data.cells[i].origin
				#if cell_origin.distance_to(other_cell_origin) < parameters.cell_origin_buffer_radius: 
					#cell_origin_isolated = false
					#break
		
		_gen_data.cells.append({
			"origin": cell_origin,
			"tiles": []
		})
	
	# Minor performance gain over repeated calls to Array.append()
	_gen_data.tiles.resize(parameters.map_size.x * parameters.map_size.y)
	
	# Calculate every tile's nearest cell origin
	for x: int in range(parameters.map_size.x):
		for y: int in range(parameters.map_size.y):
			var tile_position: Vector2i = Vector2i(x, y)
			var nearest_cell_origin_key: int = -1
			var minimum_distance: float = parameters.map_size.x * parameters.map_size.y
			for i: int in range(_gen_data.cells.size()):
				var point: Vector2i = _gen_data.cells[i].origin
				if tile_position.distance_to(point) > minimum_distance: continue
				minimum_distance = tile_position.distance_to(point)
				nearest_cell_origin_key = i
			
			# update both parallel data structures
			_gen_data.cells[nearest_cell_origin_key].tiles.append(tile_position)
			_gen_data.tiles.append({
				"position": tile_position,
				"cell": nearest_cell_origin_key
			})
